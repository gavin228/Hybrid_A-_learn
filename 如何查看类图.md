# 如何查看和理解类图

## 📄 文件说明

已生成的文件：
- `class_diagram.puml` - PlantUML 格式的标准 UML 类图（**包含所有关系符号**）
- `类图说明.md` - 详细的文字说明文档

## 🎨 查看 PlantUML 类图的方法

### 方法1：VSCode 插件（推荐）⭐

1. **安装插件**
   - 在 VSCode 中按 `Ctrl+Shift+X` 打开扩展市场
   - 搜索 `PlantUML`
   - 安装 `PlantUML` 插件（作者：jebbs）

2. **查看图表**
   - 打开 `class_diagram.puml` 文件
   - 按 `Alt+D` 预览图表
   - 或右键选择 `Preview Current Diagram`

3. **导出图片**
   - 预览后右键
   - 选择 `Export Current Diagram`
   - 可导出为 PNG、SVG、PDF 等格式

### 方法2：在线查看器 🌐

**PlantUML 官方在线服务器**
1. 访问：http://www.plantuml.com/plantuml/uml/
2. 将 `class_diagram.puml` 的内容粘贴到文本框
3. 点击 Submit 即可看到渲染的图表

**或使用这些在线编辑器：**
- https://www.planttext.com/
- https://plantuml-editor.kkeisuke.com/

### 方法3：命令行生成图片 💻

**需要先安装 PlantUML：**

```bash
# Ubuntu/Debian
sudo apt-get install plantuml

# 或使用 Java jar 包
# 下载 plantuml.jar 从 https://plantuml.com/download
```

**生成图片：**
```bash
# 生成 PNG
plantuml class_diagram.puml

# 生成 SVG (矢量图，推荐)
plantuml -tsvg class_diagram.puml

# 生成 PDF
plantuml -tpdf class_diagram.puml
```

### 方法4：IntelliJ IDEA / PyCharm 📱

1. 安装 PlantUML integration 插件
2. 打开 `.puml` 文件
3. 右侧会自动显示预览面板

## 📖 UML 关系符号详解

### 图中使用的符号对照表

```
┌─────────────────────────────────────────────────────────────────┐
│ 符号              │ 关系类型     │ 含义                       │
├─────────────────────────────────────────────────────────────────┤
│ ClassA ◆━━━ ClassB │ 组合          │ 强拥有，生命周期一致       │
│ (实心菱形)         │ Composition   │ B是A的一部分，A销毁B也销毁 │
├─────────────────────────────────────────────────────────────────┤
│ ClassA ◇━━━ ClassB │ 聚合          │ 弱拥有，生命周期独立       │
│ (空心菱形)         │ Aggregation   │ A包含B，但B可独立存在      │
├─────────────────────────────────────────────────────────────────┤
│ ClassA ────> ClassB│ 关联          │ 长期依赖                   │
│ (实线箭头)         │ Association   │ A持有B的引用/指针          │
├─────────────────────────────────────────────────────────────────┤
│ ClassA ····> ClassB│ 依赖          │ 临时使用                   │
│ (虚线箭头)         │ Dependency    │ A使用B作为参数或局部变量   │
├─────────────────────────────────────────────────────────────────┤
│ ClassA ━━▷ ClassB  │ 继承/泛化     │ is-a 关系                  │
│ (空心三角)         │ Generalization│ A是B的子类                 │
├─────────────────────────────────────────────────────────────────┤
│ ClassA ┈┈▷ Interface│ 实现         │ 接口实现                   │
│ (虚线空心三角)     │ Realization   │ A实现接口I                 │
└─────────────────────────────────────────────────────────────────┘
```

### 本项目中的具体例子

#### 1. 组合关系 (◆━━━)

```
HybridAStarFlow ◆━━━ HybridAStar
```

**源码：**
```cpp
class HybridAStarFlow {
private:
    std::shared_ptr<HybridAStar> kinodynamic_astar_searcher_ptr_;
    // ↑ HybridAStarFlow 创建并完全拥有 HybridAStar
    //   当 HybridAStarFlow 销毁时，HybridAStar 也会被销毁
};
```

**含义：**
- HybridAStar 是 HybridAStarFlow 的一部分
- 生命周期绑定
- "整体-部分"关系

#### 2. 聚合关系 (◇━━━)

```
HybridAStar ◇━━━ StateNode
```

**源码：**
```cpp
class HybridAStar {
private:
    StateNode::Ptr*** state_node_map_;
    // ↑ HybridAStar 管理多个 StateNode
    //   但 StateNode 可以独立存在
    //   只是被 HybridAStar 引用
};
```

**含义：**
- HybridAStar 包含多个 StateNode
- StateNode 可以独立存在
- "容器-元素"关系

#### 3. 依赖关系 (····>)

```
HybridAStar ····> StateNode (<<create>>)
```

**源码：**
```cpp
void HybridAStar::GetNeighborNodes(...) {
    auto node = new StateNode(grid_index);  // 临时创建
    neighbor_nodes.push_back(node);
    // ↑ 函数中临时使用 StateNode
}
```

**含义：**
- HybridAStar 临时创建 StateNode
- 不是长期持有
- 函数级别的使用关系

#### 4. 关联关系 (────>)

```
StateNode ────> StateNode (parent_node_)
```

**源码：**
```cpp
struct StateNode {
    StateNode* parent_node_;
    // ↑ 持有指向另一个 StateNode 的指针
    //   用于路径回溯
};
```

**含义：**
- StateNode 持有另一个 StateNode 的指针
- 长期关系（不是临时的）
- 成员变量级别

## 🎯 如何阅读类图

### 阅读顺序

1. **先看类名和注释**
   - 了解每个类的职责
   - 注意类的构造型（如 `<<struct>>`）

2. **再看类之间的关系线**
   - 实线 = 强关系（依赖性强）
   - 虚线 = 弱关系（偶尔使用）
   - 箭头方向 = 依赖方向

3. **最后看类的细节**
   - 属性（数据）
   - 方法（行为）
   - 访问修饰符

### 实例：追踪一个完整流程

**场景：HybridAStarFlow 如何使用 HybridAStar 进行规划**

```
1. HybridAStarFlow ◆━━━ HybridAStar
   (组合关系：HybridAStarFlow 拥有 HybridAStar)
   
2. HybridAStarFlow 调用 HybridAStar::Search()
   (通过成员变量调用)
   
3. HybridAStar::Search() ····> StateNode
   (依赖关系：临时创建 StateNode)
   
4. HybridAStar ◇━━━ StateNode
   (聚合关系：管理多个 StateNode)
   
5. StateNode ────> StateNode
   (关联关系：parent_node_ 指针)
```

**对应的调用链：**
```cpp
HybridAStarFlow::Run() {
    // 1. 拥有 HybridAStar
    kinodynamic_astar_searcher_ptr_->Search(...);
    
    // 2. Search 内部
    HybridAStar::Search() {
        // 3. 创建节点（依赖）
        auto node = new StateNode(...);
        
        // 4. 管理节点（聚合）
        state_node_map_[i][j][k] = node;
        
        // 5. 节点之间关联
        node->parent_node_ = current_node;
    }
}
```

## 📚 多重性标记

```
HybridAStarFlow ◆━━━ "1" HybridAStar
                      ↑
                    多重性
```

**常用标记：**
- `1` : 恰好一个
- `0..1` : 零个或一个
- `*` 或 `0..*` : 零个或多个
- `1..*` : 一个或多个
- `3..5` : 3到5个

**示例：**
```
HybridAStar ◇━━━ "0..*" StateNode
```
含义：一个 HybridAStar 可以包含 0 到多个 StateNode

## 🔍 实践练习

### 练习1：识别关系

看代码，判断关系类型：

```cpp
class Car {
    Engine* engine_;        // ❓ 什么关系？
    void drive(Road& r);    // ❓ 什么关系？
};
```

<details>
<summary>点击查看答案</summary>

- `Engine* engine_` → **组合或聚合**（取决于谁创建和销毁）
- `void drive(Road& r)` → **依赖**（临时使用参数）
</details>

### 练习2：画出关系

根据源码，在图上标注关系：

```cpp
class HybridAStarFlow {
    std::shared_ptr<CostMapSubscriber> costmap_sub_ptr_;
};
```

<details>
<summary>点击查看答案</summary>

```
HybridAStarFlow ◆━━━ "1" CostMapSubscriber
```
组合关系，因为是 shared_ptr，生命周期绑定
</details>

### 练习3：阅读完整交互

在类图中追踪这个流程：
1. HybridAStarFlow 接收地图数据
2. 调用 HybridAStar 进行搜索
3. HybridAStar 创建 StateNode
4. 使用 RSPath 计算启发值

## 🛠️ 工具推荐

### VSCode 插件
- **PlantUML** (jebbs.plantuml) - 预览和导出
- **PlantUML Previewer** - 实时预览

### 在线工具
- **PlantText** - https://www.planttext.com/
- **PlantUML Online Server** - http://www.plantuml.com/plantuml/

### 桌面应用
- **Visual Paradigm** - 专业 UML 工具
- **StarUML** - 免费开源
- **Umlet** - 轻量级

## 📝 总结

### 为什么要用 PlantUML？

✅ **文本描述** - 易于版本控制
✅ **标准UML** - 符合业界规范
✅ **自动布局** - 无需手动调整
✅ **可导出** - 支持多种格式
✅ **可维护** - 易于修改和更新

### 关系符号记忆口诀

```
实心菱形"拥有"，空心菱形"包含"
实线箭头"持有"，虚线箭头"偶然"
空心三角"继承"，虚线三角"实现"
```

### 下一步

1. ✅ 用上面的方法查看生成的类图
2. ✅ 对照源码理解每个类
3. ✅ 识别类之间的关系
4. ✅ 尝试修改类图添加新类
5. ✅ 为自己的项目画类图

## ❓ 常见问题

**Q: 为什么类图中看不到所有方法？**
A: 为了简洁，只列出了关键方法。完整方法可以查看源码。

**Q: 组合和聚合有什么区别？**
A: 组合是强拥有（生命周期一致），聚合是弱拥有（生命周期独立）。

**Q: 箭头方向代表什么？**
A: 箭头指向被依赖的类。A→B 表示 A 依赖 B。

**Q: 可以用其他工具画类图吗？**
A: 可以！但 PlantUML 的优势是文本化，便于版本控制和自动生成。

## 📞 需要帮助？

如果有任何问题：
1. 查看 PlantUML 官方文档：https://plantuml.com/zh/class-diagram
2. 参考本项目的 `类图说明.md` 文档
3. 随时提问！

---

**祝学习愉快！** 🎓
通过类图，你能更清晰地理解项目架构！

